pragma circom 2.0.0;

template MiMC5() {
    signal input x;
    signal input k;
    signal output h;

    var nRounds = 10;

    var c[nRounds] = [
        0,
        11790748410223527345390909814687588371885382763772825351543167470901489816612,
        1002911549339539658377423200448895511474178099785226016109980086225434649323,
        110242190823325713623819971200196769803001304286517225150399186566638673949080,
        92253590274059621527484079561227874122059465975149439263549011875387910519048,
        36447742275481271534062510815616296830770662941608263027911487293204752229286,
        48208090328584166326818154547132934836692048925297693078917257437796899782898,
        87766239400783694851720975669017450970854610841971927525170120558046215505984,
        83290340443567497470632107297170015013685643518332343682124543593529032761066,
        300388232167470216951765200439909111049689701122247191508120485124813329604
    ];

    signal lastOutput[nRounds + 1];
    var base[nRounds];
    signal base2[nRounds];
    signal base4[nRounds];

    lastOutput[0] <== x;

    // Ek(x) = (Fr-1∘Fr-2∘.....∘F0)(x) + k
    // (f ∘ g)(x) = f(g(x))

    for(var i = 0 ; i < nRounds; i++){
        base[i] = lastOutput[i] + k + c[i];
        base2[i] <== base[i] * base[i];
        base4[i] <== base2[i] * base2[i];
        
        lastOutput[i + 1] <== base4[i] * base[i];
    }

    h <== lastOutput[nRounds] + k;
}

component main = MiMC5();